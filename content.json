{"meta":{"title":"Joyo Blog","subtitle":"体验生活，全面发展","description":"Joyo的Hexo博客，互联网，Java，Go，分布式，大数据。","author":"Joyo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-20T03:18:44.368Z","updated":"2019-11-20T03:18:44.367Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-11-20T03:10:50.208Z","updated":"2019-11-20T03:10:50.207Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-11-20T03:52:38.000Z","updated":"2019-11-20T03:56:44.853Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-11-20T03:13:07.729Z","updated":"2019-11-20T03:13:07.728Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-11-20T03:17:45.821Z","updated":"2019-11-20T03:17:45.820Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-11-20T04:01:25.053Z","updated":"2019-11-20T04:01:25.051Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis系列篇——初识Redis","slug":"redisBasics","date":"2019-11-23T07:14:46.000Z","updated":"2019-11-23T11:48:56.555Z","comments":true,"path":"2019/11/23/redisBasics/","link":"","permalink":"http://yoursite.com/2019/11/23/redisBasics/","excerpt":"记住Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。 redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。","text":"记住Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。 redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。 什么是Redis？ 记住Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。 redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。 Redis广泛被应用于并发编程下，主要作用于缓存机制和分布式处理等领域，使系统性能以及并发得到优化。 什么是NoSql？ NoSql意为非关系型数据库，相对于关系型数据库具有更多的灵活应用场景。 NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。 NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 NoSql的主要四种类型和代表性作品 键值对数据库：Redis 列存储数据库：HBase 文档类型数据库：MongoDb 图形数据库：Neo4J， InfoGrid， Infinite Graph 为什么Redis受欢迎？越来越多的人开始应用Redis？ 基于内存，数据读写速度快，单机Redis能处理10W+的请求 单线程模型，避免了多线程频繁进行上下文切换的时间消耗 支持多种数据结构 基于非阻塞的多路复用IO机制 Redis支持什么数据结构？ 字符串类型：String 哈希类型：Hash 列表类型：List 集合类型：Set 有序集合类型：sort Set Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub 如果你还想加分，那你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML Redis中文api参考1 Redis中文api参考2 Redis的应用场景 数据缓存 任务队列 应用排行榜 网站访问统计 数据统计处理 分布式集群架构中的分布式锁 Redis的数据持久化方式 RDB（快照） AOF（追加式） 无持久化 同时使用RDB和AOF Redis的两种持久化的对比 RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。（1小时或者半小时） AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。 Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。 RDB很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。比起AOF，在数据量比较大的情况下，RDB的启动速度更快。 RDB最大的缺点：RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。 AOF比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。不会出现停电后数据丢失的情况。 AOF的缺点就是在相同的数据集下，AOF文件的大小一般会比RDB文件大。在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。 三种键过期策略 Redis是基于键值对的储存方式存放在内存中的,因此，及时对内存中的键值进行清理是非常有必要的 定时过期 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。 该策略可以立即清除过期的数据，对内存很友好； 但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 惰性过期 只有当访问一个key时，才会判断该key是否已过期，过期则清除。 该策略可以最大化地节省CPU资源，却对内存非常不友好。 极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 定期过期 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。 该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 Redis中同时使用了惰性过期和定期过期两种过期策略。 Redis的淘汰策略什么时候触发？Redis的内存淘汰策略，是指当内存使用达到maxmemory极限时，需要使用LAU淘汰算法来决定清理掉哪些数据，以保证新数据的存入。 Redis默认的淘汰策略——LRU Redis默认情况下就是使用LRU策略算法，LRU算法(least RecentlyUsed),最近最少使用算法,也就是说默认删除最近最少使用的键。 要注意一点！Redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取3个键，删除这三个键中最近最少使用的键。 那么3这个数字也是可以设置采样的大小，如果设置为10，那么效果会更好，不过也会耗费更多的CPU资源。 对应位置是Redis配置文件中的maxmeory-samples进行设置。 Redis的maxmemory极限 上面说到了当内存达到了maxmemory极限就会触发内存淘汰策略，maxmemory用来设置redis存放数据的最大的内存大小，一旦超出这个内存大小之后，就会立即使用LRU算法清理掉部分数据。 对于64 bit的机器，如果maxmemory设置为0，那么就默认不限制内存的使用，直到耗尽机器中所有的内存为止。 但是对于32 bit的机器，有一个隐式的闲置就是3GB。 Redis的数据淘汰策略 选择使用哪一种淘汰策略可以到配置文件修改maxmemory-policy字段 1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。 2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。 3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。 4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。 5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。 缓存的清理过程 1）客户端执行数据写入操作 2）redis server接收到写入操作之后，检查maxmemory的限制，如果超过了限制，那么就根据对应的policy清理掉部分数据 3）写入操作完成执行。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}]}