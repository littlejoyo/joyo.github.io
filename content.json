{"meta":{"title":"Joyo Blog","subtitle":"体验生活，全面发展","description":"Joyo的Hexo博客，互联网，Java，Go，分布式，大数据。","author":"Joyo","url":"https://littlejoyo.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-20T03:18:44.368Z","updated":"2019-11-20T03:18:44.367Z","comments":true,"path":"404/index.html","permalink":"https://littlejoyo.github.io/404/index.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-11-20T03:10:50.208Z","updated":"2019-11-20T03:10:50.207Z","comments":true,"path":"about/index.html","permalink":"https://littlejoyo.github.io/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-11-20T03:17:45.821Z","updated":"2019-11-20T03:17:45.820Z","comments":true,"path":"mylist/index.html","permalink":"https://littlejoyo.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-11-20T03:13:07.729Z","updated":"2019-11-20T03:13:07.728Z","comments":true,"path":"categories/index.html","permalink":"https://littlejoyo.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-11-20T03:52:38.000Z","updated":"2019-11-20T03:56:44.853Z","comments":true,"path":"archives/index.html","permalink":"https://littlejoyo.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-11-20T04:01:25.053Z","updated":"2019-11-20T04:01:25.051Z","comments":true,"path":"tags/index.html","permalink":"https://littlejoyo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis系列篇：两种持久化方式的对比","slug":"persistence","date":"2019-11-24T13:37:49.000Z","updated":"2019-11-24T13:45:25.944Z","comments":true,"path":"2019/11/24/persistence/","link":"","permalink":"https://littlejoyo.github.io/2019/11/24/persistence/","excerpt":"Redis的两种持久化的方式：RDB（快照）和 AOF（追加式）。 RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。 AOF持久化方式则会记录每一个服务器收到的写操作。","text":"Redis的两种持久化的方式：RDB（快照）和 AOF（追加式）。 RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。 AOF持久化方式则会记录每一个服务器收到的写操作。 文章参考来源 Github issues文章地址 : https://github.com/littlejoyo/Blog/issues/4 Redis的两种持久化方式 分别是RDB（快照）和 AOF（追加式） RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。 AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录会以追加的方式进行保存。 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。 Redis加载持久化数据流程： RDB工作原理 Redis调用fork()，产生一个子进程。 子进程把数据写到一个临时的RDB文件。 当子进程写完新的RDB文件后，把旧的RDB文件替换掉。 优点 RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。 基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上。 RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。 比起AOF，在数据量比较大的情况下，RDB的启动速度更快。 缺点 RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。 RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。 如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。 文件路径和名称 默认Redis会把RDB快照文件存储为当前目录下一个名为dump.rdb的文件。 如果要修改文件的存储路径和名称，可以通过修改配置文件redis.conf实现： 12345# RDB文件名，默认为dump.rdb。dbfilename dump.rdb# 文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。dir ./ RDB的启用和禁用（保存点） 保存点可以进行配置，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。 例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件： 1save 60 1000 保存点可以设置多个，Redis的配置文件就默认设置了3个保存点： 12345# 格式为：save &lt;seconds&gt; &lt;changes&gt;# 可以设置多个。save 900 1 #900秒后至少1个key有变动save 300 10 #300秒后至少10个key有变动save 60 10000 #60秒后至少10000个key有变动 如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置： 1save &quot;&quot; 错误处理和提醒 默认情况下，如果Redis在后台生成快照的时候失败，那么就会停止接收数据，目的是让用户能知道数据没有持久化成功。 但是如果你有其他的方式可以监控到Redis及其持久化的状态，那么可以把这个功能禁止掉。 1stop-writes-on-bgsave-error yes 数据压缩 默认Redis会采用LZF对数据进行压缩。 如果你想节省点CPU的性能，你可以把压缩功能禁用掉，但是数据集就会比没压缩的时候要大。 1rdbcompression yes 数据校验 从版本5的RDB的开始，一个CRC64的校验码会放在文件的末尾。这样更能保证文件的完整性，但是在保存或者加载文件时会损失一定的性能（大概10%）。 如果想追求更高的性能，可以把它禁用掉，这样文件在写入校验码时会用0替代，加载的时候看到0就会直接跳过校验。 1rdbchecksum yes 手动生成快照备份数据 Redis提供了两个命令用于生成快照 SAVE SAVE命令会使用同步的方式生成RDB快照文件，这意味着在这个过程中会阻塞所有其他客户端的请求。 因此不建议在生产环境使用这个命令，除非因为某种原因需要去阻止Redis使用子进程进行后台生成快照（例如调用fork(2)出错）。 BGSAVE BGSAVE命令使用后台的方式保存RDB文件，调用此命令后，会立刻返回OK返回码。 Redis会产生一个子进程进行处理并立刻恢复对客户端的服务。 在客户端我们可以使用LASTSAVE命令查看操作是否成功。 1234127.0.0.1:6379&gt; BGSAVEBackground saving started127.0.0.1:6379&gt; LASTSAVE(integer) 1433936394 注意：配置文件里禁用了快照生成功能不影响SAVE和BGSAVE命令的效果。 AOF 快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。 但是AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里。 当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。 优点 比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。 默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。 AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用redis-check-aof这个工具很简单的进行修复。 当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。 新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上。 AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。 例如我们不小心用FLUSHALL命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来。 缺点 在相同的数据集下，AOF文件的大小一般会比RDB文件大。 在某些fsync策略下，AOF的速度会比RDB慢。 通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。 启用AOF 把配置项appendonly设为yes： 1appendonly yes 文件路径和名称12345# 文件存放目录，与RDB共用。默认为当前工作目录。dir ./# 默认文件名为appendonly.aofappendfilename \"appendonly.aof\" Redis的三种fsync方式 每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全。 每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）。 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般。 推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。相关配置如下： 123# appendfsync alwaysappendfsync everysec# appendfsync no 日志重写 随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件。 工作原理如下： Redis调用fork()，产生一个子进程。 子进程把新的AOF写到一个临时文件里。 主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全。 当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里。 我们可以通过配置设置日志重写的条件： 123456# Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。# 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。# 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 要禁用自动的日志重写功能，我们可以把百分比设置为0： 1auto-aof-rewrite-percentage 0 Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行BGREWRITEAOF这个命令。 数据损坏修复如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复： 1.备份AOF文件。 2.使用redis-check-aof命令修复原始的AOF文件： 1$ redis-check-aof --fix 3.可以使用diff -u命令看下两个文件的差异。 4.使用修复过的文件重启Redis服务。 从RDB切换到AOF 这里只说Redis &gt;= 2.2版本的方式： 备份一个最新的dump.rdb的文件，并把备份文件放在一个安全的地方。 运行以下两条命令： 12$ redis-cli config set appendonly yes$ redis-cli config set save \"\" 确保数据跟切换前一致。 确保数据正确的写到AOF文件里。 第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。记得对配置文件redis.conf进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。 Redis数据备份建议的备份方法： 创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。 定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。 每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://littlejoyo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://littlejoyo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://littlejoyo.github.io/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"https://littlejoyo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Redis系列篇：初识Redis","slug":"redisBasics","date":"2019-11-23T07:14:46.000Z","updated":"2019-11-24T13:38:31.794Z","comments":true,"path":"2019/11/23/redisBasics/","link":"","permalink":"https://littlejoyo.github.io/2019/11/23/redisBasics/","excerpt":"Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。 Redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。","text":"Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。 Redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。 什么是Redis？ Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。 Redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。 Redis广泛被应用于并发编程下，主要作用于缓存机制和分布式处理等领域，使系统性能以及并发得到优化。 什么是NoSql？ NoSql意为非关系型数据库，相对于关系型数据库具有更多的灵活应用场景。 NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。 NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 NoSql的主要四种类型和代表性作品 键值对数据库：Redis 列存储数据库：HBase 文档类型数据库：MongoDb 图形数据库：Neo4J， InfoGrid， Infinite Graph 为什么Redis受欢迎？越来越多的人开始应用Redis？ 基于内存，数据读写速度快，单机Redis能处理10W+的请求 单线程模型，避免了多线程频繁进行上下文切换的时间消耗 支持多种数据结构 基于非阻塞的多路复用IO机制 Redis支持什么数据结构？ 字符串类型：String 哈希类型：Hash 列表类型：List 集合类型：Set 有序集合类型：sort Set Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub 如果你还想加分，那你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML Redis中文api参考1 Redis中文api参考2 Redis的应用场景 数据缓存 任务队列 应用排行榜 网站访问统计 数据统计处理 分布式集群架构中的分布式锁 Redis的数据持久化方式 RDB（快照） AOF（追加式） 无持久化 同时使用RDB和AOF Redis的两种持久化的对比 RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。（1小时或者半小时） AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。 Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。 RDB很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。比起AOF，在数据量比较大的情况下，RDB的启动速度更快。 RDB最大的缺点：RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。 AOF比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。不会出现停电后数据丢失的情况。 AOF的缺点就是在相同的数据集下，AOF文件的大小一般会比RDB文件大。在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。 三种键过期策略 Redis是基于键值对的储存方式存放在内存中的,因此，及时对内存中的键值进行清理是非常有必要的 定时过期 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。 该策略可以立即清除过期的数据，对内存很友好； 但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 惰性过期 只有当访问一个key时，才会判断该key是否已过期，过期则清除。 该策略可以最大化地节省CPU资源，却对内存非常不友好。 极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 定期过期 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。 该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 Redis中同时使用了惰性过期和定期过期两种过期策略。 Redis的淘汰策略什么时候触发？Redis的内存淘汰策略，是指当内存使用达到maxmemory极限时，需要使用LAU淘汰算法来决定清理掉哪些数据，以保证新数据的存入。 Redis默认的淘汰策略——LRU Redis默认情况下就是使用LRU策略算法，LRU算法(least RecentlyUsed),最近最少使用算法,也就是说默认删除最近最少使用的键。 要注意一点！Redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取3个键，删除这三个键中最近最少使用的键。 那么3这个数字也是可以设置采样的大小，如果设置为10，那么效果会更好，不过也会耗费更多的CPU资源。 对应位置是Redis配置文件中的maxmeory-samples进行设置。 Redis的maxmemory极限 上面说到了当内存达到了maxmemory极限就会触发内存淘汰策略，maxmemory用来设置redis存放数据的最大的内存大小，一旦超出这个内存大小之后，就会立即使用LRU算法清理掉部分数据。 对于64 bit的机器，如果maxmemory设置为0，那么就默认不限制内存的使用，直到耗尽机器中所有的内存为止。 但是对于32 bit的机器，有一个隐式的闲置就是3GB。 Redis的数据淘汰策略 选择使用哪一种淘汰策略可以到配置文件修改maxmemory-policy字段 1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。 2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。 3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。 4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。 5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。 缓存的清理过程 1）客户端执行数据写入操作 2）redis server接收到写入操作之后，检查maxmemory的限制，如果超过了限制，那么就根据对应的policy清理掉部分数据 3）写入操作完成执行。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://littlejoyo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://littlejoyo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://littlejoyo.github.io/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"https://littlejoyo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}]}