---
title: Redis基础篇：初识Redis中间件
date: 2019-11-18 15:03:16
categories:
  - [数据库]
  - [Redis]
tag:
    - 数据库
    - Redis
    - 中间件
---
Redis基础篇：初识Redis中间件。
- Redis既是一种中间件，也是一种数据库；

- 与Mysql不同的是，Mysql是关系型数据库，而Redis是非关系型的数据库；

- 本篇基础篇主要展开对Nosql和Redis的理解和基本的运用。

![Redis](https://i.loli.net/2019/12/09/2aAYzLyjNuPn4if.png)
<!-- more -->

> Github issues:https://github.com/littlejoyo/Blog/issues/

> 个人博客：https://littlejoyo.github.io/

> 掘金：https://juejin.im/user/59c1c16f6fb9a00a4c270402

> 微信公众号：Joyo说

![weixin](https://i.loli.net/2020/01/11/NJIXozj5WAxgCiu.png)


# 1.什么是Redis？

- Redis是一款键值对（key-value）形式的NoSql数据库，NoSql = not only Sql，高性能解决高并发的需求。由C语言开发。

- Redis是基于内存的，内存的读写速度非常快，对于数据的读取和写入比常见的关系型数据库快许多。

- Redis广泛被应用于并发编程下，主要作用于缓存机制和分布式处理等领域，使系统性能以及并发得到优化。

# 2.什么是NoSql？
- NoSql意为非关系型数据库，相对于关系型数据库具有更多的灵活应用场景。

- NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。

- NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。

- NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。

# 3.NoSql的主要四种类型和代表性作品

- 键值对数据库：Redis

- 列存储数据库：HBase

- 文档类型数据库：MongoDb

- 图形数据库：Neo4J， InfoGrid， Infinite Graph

# 4.为什么Redis受欢迎？越来越多的人开始应用Redis？

- 基于内存，数据读写速度快，单机Redis能处理10W+的请求

- 单线程模型，避免了多线程频繁进行上下文切换的时间消耗

- 支持多种数据结构

- 基于非阻塞的多路复用IO机制

# 5.Redis支持什么数据结构？

- 字符串类型：String

- 哈希类型：Hash

- 列表类型：List

- 集合类型：Set

- 有序集合类型：sort Set

- Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub

- 如果你还想加分，那你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML

[Redis中文api参考1](http://doc.redisfans.com/)

[Redis中文api参考2](http://redisdoc.com/index.html)

# 6.Redis的应用场景
- 数据缓存
- 任务队列
- 应用排行榜
- 网站访问统计
- 数据统计处理
- 分布式集群架构中的分布式锁

# 7.Redis的数据持久化方式
- RDB（快照）
- AOF（追加式）
- 无持久化
- 同时使用RDB和AOF

# 8.Redis的两种持久化的对比
- RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。（1小时或者半小时）

- AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。

- Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。

- 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。

- RDB很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。比起AOF，在数据量比较大的情况下，RDB的启动速度更快。

- RDB最大的缺点：RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。

- AOF比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。不会出现停电后数据丢失的情况。

- AOF的缺点就是在相同的数据集下，AOF文件的大小一般会比RDB文件大。在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平。

# 9.三种键过期策略
> Redis是基于键值对的储存方式存放在内存中的,因此，及时对内存中的键值进行清理是非常有必要的

## 9.1 定时过期
- 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。

- 该策略可以立即清除过期的数据，对内存很友好；

- 但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

## 9.2 惰性过期
- 只有当访问一个key时，才会判断该key是否已过期，过期则清除。

- 该策略可以最大化地节省CPU资源，却对内存非常不友好。

- 极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

## 9.3 定期过期
- 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。
- 该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

- Redis中同时使用了惰性过期和定期过期两种过期策略。

# 10.Redis的淘汰策略

## 10.1 什么时候触发？

Redis的内存淘汰策略，是指当内存使用达到maxmemory极限时，需要使用LAU淘汰算法来决定清理掉哪些数据，以保证新数据的存入。

## 10.2 Redis默认的淘汰策略——LRU
- Redis默认情况下就是使用LRU策略算法，LRU算法(least RecentlyUsed),最近最少使用算法,也就是说默认删除最近最少使用的键。

- 要注意一点！Redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取3个键，删除这三个键中最近最少使用的键。

- 那么3这个数字也是可以设置采样的大小，如果设置为10，那么效果会更好，不过也会耗费更多的CPU资源。

- 对应位置是Redis配置文件中的`maxmeory-samples`进行设置。

## 10.3 Redis的maxmemory极限
- 上面说到了当内存达到了maxmemory极限就会触发内存淘汰策略，maxmemory用来设置redis存放数据的最大的内存大小，一旦超出这个内存大小之后，就会立即使用LRU算法清理掉部分数据。

- 对于64 bit的机器，如果maxmemory设置为0，那么就默认不限制内存的使用，直到耗尽机器中所有的内存为止。

- 但是对于32 bit的机器，有一个隐式的闲置就是3GB。

## 10.4 Redis的数据淘汰策略

> 选择使用哪一种淘汰策略可以到配置文件修改`maxmemory-policy`字段

- 1）`noeviction`：当内存不足以容纳新写入数据时，新写入操作会报错。

- 2）`allkeys-lru`：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。

- 3）`allkeys-random`：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

- 4）`volatile-lru`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。

- 5）`volatile-random`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。

- 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## 10.5 缓存的清理过程

- 1）客户端执行数据写入操作
- 2）redis server接收到写入操作之后，检查`maxmemory`的限制，如果超过了限制，那么就根据对应的policy清理掉部分数据
- 3）写入操作完成执行。

# 微信公众号

> 扫一扫关注Joyo说公众号，共同学习和研究开发技术。

![weixin-a](https://i.loli.net/2020/01/11/HQT8NMsmDhIkXZv.png)
